/**
 *-----------------------------------------------------------------------------
 * Title      : YCPSW EPICS module driver
 * ----------------------------------------------------------------------------
 * File       : drvYCPSWASYN.cpp
 * Author     : Jesus Vasquez, jvasquez@slac.stanford.edu
 * Created    : 2016-08-25
 * ----------------------------------------------------------------------------
 * Description:
 * YCPSW EPICS module driver.
 * ----------------------------------------------------------------------------
 * This file is part of l2Mps. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of l2Mps, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#include <getopt.h>
#include <sstream>
#include <boost/array.hpp>
#include <iostream>
#include <fstream>
#include <math.h>
#include <sys/mman.h>
#include <sched.h>
#include <epicsTypes.h>
#include <epicsTime.h>
#include <epicsThread.h>
#include <epicsString.h>
#include <epicsTimer.h>
#include <epicsMutex.h>
#include <epicsEvent.h>
#include <iocsh.h>
#include <sha1.hpp>
#include <ctype.h>
#include <iomanip>
#include <stdexcept>

#include <dbAccess.h>
#include <dbStaticLib.h>

#include "drvYCPSWASYN.h"
#include "asynPortDriver.h"
#include <epicsExport.h>

#include <cpsw_api_builder.h>
#include <cpsw_api_user.h>
#include <yaml-cpp/yaml.h>

#include <yamlLoader.h>

#define MY_PRIORITY (49) /* we use 49 as the PRREMPT_RT use 50
                            as the priority of kernel tasklets
                            and interrupt handler by default */

#define MAX_SAFE_STACK (65536)  /* The maximum stack size which is
                                   guaranteed safe to access without
                                   faulting */

using std::string;
using std::stringstream;

// Default values
double       YCPSWASYN::defaultScan      = 0.0;
unsigned int YCPSWASYN::recordNameLenMax = sizeof( ((dbCommon*)0)->name ) - 1;
std::string  YCPSWASYN::mapFilePath      = "yaml/";
std::string  YCPSWASYN::debugFilePath    = "/tmp/";

YCPSWASYN::YCPSWASYN(const char *portName, Path p, const char *recordPrefix, int autogenerationMode, const char* dictionary)
    : asynPortDriver(
        portName,                                                                                   // Port Name
        MAX_SIGNALS,                                                                                // Max Address
        asynInt32Mask | asynDrvUserMask | asynInt16ArrayMask | asynInt32ArrayMask | asynOctetMask | \
        asynFloat64ArrayMask | asynUInt32DigitalMask | asynFloat64Mask,                             // Interface Mask
        asynInt16ArrayMask | asynInt32ArrayMask | asynInt32Mask | asynUInt32DigitalMask,            // Interrupt Mask
        ASYN_MULTIDEVICE | ASYN_CANBLOCK,                                                           // asynFlags
        1,                                                                                          // Autoconnect
        0,                                                                                          // Default priority
        0),                                                                                         // Default stack size
    driverName_(DRIVER_NAME),
    p_(p),
    portName_(portName),
    recordPrefix_(recordPrefix),
    nRO(0),
    nRW(0),
    nCMD(0),
    nSTM(0),
    nFO(0),
    nFW(0),
    recordCount(0),
    autogenerationMode_(autogenerationMode)
{

    // In mode 1 (auto-generation using maps, check the PV name length respect to the prefix's
    if ( ( autogenerationMode_ == 1 ) && ( recordNameLenMax <= ( recordPrefix_.length() + 4 ) ) )
    {
        fprintf( stderr, "Error: PV name length (%d) must be greater than the length of the prefix (%zu) + 4\n", recordNameLenMax, recordPrefix_.length() );

        recordNameLenMax = sizeof( ((dbCommon*)0)->name ) - 1;
        fprintf( stderr, "Using default length (%d) instead\n", recordNameLenMax );
    }

    if (autogenerationMode_)
        autogenerateDatabase();


    loadDBFromFile(dictionary);

    // Create parameters and load records related to save/load default functions
    createParam(DEV_CONFIG, loadConfigString,       asynParamInt32,         &loadConfigValue_);
    createParam(DEV_CONFIG, saveConfigString,       asynParamInt32,         &saveConfigValue_);
    createParam(DEV_CONFIG, loadConfigFileString,   asynParamOctet,         &loadConfigFileValue_);
    createParam(DEV_CONFIG, saveConfigFileString,   asynParamOctet,         &saveConfigFileValue_);
    createParam(DEV_CONFIG, loadConfigStatusString, asynParamUInt32Digital, &loadConfigStatusValue_);
    createParam(DEV_CONFIG, saveConfigStatusString, asynParamUInt32Digital, &saveConfigStatusValue_);
    createParam(DEV_CONFIG, loadConfigRootString,   asynParamOctet,         &loadConfigRootValue_);
    createParam(DEV_CONFIG, saveConfigRootString,   asynParamOctet,         &saveConfigRootValue_);

    // Set initial values for these parameters in the parameter library
    setIntegerParam(DEV_CONFIG,     loadConfigValue_,     0);
    setIntegerParam(DEV_CONFIG,     saveConfigValue_,     0);
    setStringParam(DEV_CONFIG,      loadConfigFileValue_, "");
    setStringParam(DEV_CONFIG,      saveConfigFileValue_, "");
    setStringParam(DEV_CONFIG,      loadConfigRootValue_, "");
    setStringParam(DEV_CONFIG,      saveConfigRootValue_, "");
    setUIntDigitalParam(DEV_CONFIG, saveConfigStatusValue_, CONFIG_STAT_IDLE, PROCESS_CONFIG_MASK);
    setUIntDigitalParam(DEV_CONFIG, loadConfigStatusValue_, CONFIG_STAT_IDLE, PROCESS_CONFIG_MASK);
}


///////////////////////////////////
// + Stream acquisition routines //
///////////////////////////////////
static void streamTaskC(void *args)
{
    ThreadArgs *arglist = static_cast<ThreadArgs*>(args);

    YCPSWASYN *pYCPSWASYN = (YCPSWASYN *)arglist->pPvt;
    pYCPSWASYN->streamTask(arglist->stm, arglist->param16index, arglist->param32index);
}

/////////////////////////////////////////////////////////////////////////////////
// void YCPSWASYN::streamTask(Stream stm, int param16index, int param32index); //
//                                                                             //
// - Stream handling function                                                  //
/////////////////////////////////////////////////////////////////////////////////
void YCPSWASYN::streamTask(Stream stm, int param16index, int param32index)
{
    int64_t got = 0;
    int64_t lastGot = 0;
    size_t nWords16, nWords32, nBytes;
    int nFrame;
    uint8_t *buf = new uint8_t[STREAM_MAX_SIZE];
    struct sched_param  param;

    if (!stm)
    {
        printf("Error on stream handler\n");
        return;
    }

    // Declare as real time task
    param.sched_priority = MY_PRIORITY;
    if(sched_setscheduler(0, SCHED_FIFO, &param) == -1)
    {
        perror("sched_setscheduler failed on stream handler");
    }

    // Lock memory
    if(mlockall(MCL_CURRENT|MCL_FUTURE) == -1)
    {
        perror("mlockall failed on stream handler");
    }

    // Pre-fault our stack
    unsigned char dummy[MAX_SAFE_STACK];
    memset(dummy, 0, MAX_SAFE_STACK);

// + Generate fake data //
    /*
    epicsInt32 *fakeData = (epicsInt32 *)calloc(n, sizeof(epicsInt32));

    for (int i = 0 ; i < n ; i++)
    {
        *(fakeData+i) = (epicsInt32)(10000+1000*sin(2*3.14*i*(pIndex+1)/n));
    }

    while(1)
    {
        std::copy(fakeData, fakeData+n, buffer);
        doCallbacksInt32Array(buffer, n, pIndex, DEV_STM);
        epicsThreadSleep(1);
    }
    */
// - Generate fake data //

    try
    {
        while(1)
        {
            got = stm->read( buf, STREAM_MAX_SIZE, CTimeout(-1));

            if(got > 8)
            {
                lock();
                nBytes = (got - 9); // header = 8 bytes, footer = 1 byte, data = 32bit words.
                nWords16 = nBytes / 2;
                nWords32 = nWords16 / 2;

                nFrame = (buf[1]<<4) | (buf[0] >> 4);

                asynPrint(pasynUserSelf, ASYN_TRACEIO_FILTER, \
                          "got = %zu bytes (%zu 32-bit words, %zu 16-bit words). Fame # %d\n", nBytes, nWords32, nWords16, nFrame \
                          );

                doCallbacksInt16Array((epicsInt16*)(buf+8), nWords16, param16index, DEV_STM);
                doCallbacksInt32Array((epicsInt32*)(buf+8), nWords32, param32index, DEV_STM);

                if (lastGot > got)
                    memset(buf+got, 0, (lastGot-got)*sizeof(uint8_t));

                lastGot = got;

                unlock();
            }
            else
            {
                 asynPrint(pasynUserSelf, ASYN_TRACE_ERROR, "%s: Received frame too small\n", driverName_);
            }
        }
    }
    catch(IntrError &e)
    {
        delete[] buf;
    }

    return;
}

///////////////////////////////////
// - Stream acquisition routines //
///////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////
// int YCPSWASYN::YCPSWASYNInit(const char *yaml_doc, Path *p, const char *ipAddr) //
// - Initialization routine                                                        //
//                                                                                 //
/////////////////////////////////////////////////////////////////////////////////////
class IYamlSetIP : public IYamlFixup
{
    public:
        IYamlSetIP( const char* ip_addr ) : ip_addr_(ip_addr) {}

        void operator()(YAML::Node &node)
        {
            node["ipAddr"] = ip_addr_;
        }

        ~IYamlSetIP() {}

    private:
        std::string ip_addr_;
};

int YCPSWASYN::YCPSWASYNInit(const char* rootPath, Path *p, const char* namedRoot)
{
    Path root;

    // Try first to get the root from the cpswLoadYamlFile module
    if ( ( ! namedRoot ) || ( namedRoot[0] == '\0' ) )
    {
        printf("Root name empty or not defined. Calling cpswGetRoot()\n");
        root = cpswGetRoot();
    }
    else
    {
        printf("Root name defined. Calling cpswGetiNamedRoot(%s)\n", namedRoot);
        root = cpswGetNamedRoot(namedRoot);
    }

    if (!root)
    {
        fprintf(stderr, "ERROR: cpswGetRoot() returned an empty root.\n");
        fprintf(stderr, "Did you forget to called the yamlLoder module first?.\n");
        fprintf(stderr, "Aborting...\n");

        throw std::runtime_error( "cpswGetRoot() returned an empty root." );
    }

    printf("cpswGetRoot() returned a non-empty root...\n");

    *p = root;

    if (rootPath[0] == '\0')
    {
        printf("Stating at root\n");
    }
    else
    {
        try
        {
            *p = root->findByName(rootPath);
        }
        catch (CPSWError &e)
        {
            fprintf(stderr, "Path not found! (CPSW error: %s). Starting at root\n", e.getInfo().c_str());
        }
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// int YCPSWASYN::LoadRecord(int regType, const recordParams& rp, const string& dbParams); //
//                                                                                         //
// - Load a EPICS record with the provided information                                     //
/////////////////////////////////////////////////////////////////////////////////////////////
//template <typename T>
int YCPSWASYN::LoadRecord(int regType, const recordParams& rp, const string& dbParams, Path p)
{
    int paramIndex;
    stringstream dbParamsLocal;

    // Create list of parameter to pass to the  dbLoadRecords function
    dbParamsLocal.str("");
    dbParamsLocal << "PORT=" << portName_;
    dbParamsLocal << ",ADDR=" << regType;
    dbParamsLocal << ",R=" << rp.recName;
    dbParamsLocal << ",PARAM=" << rp.paramName;
    dbParamsLocal << ",DESC=" << rp.recDesc;
    dbParamsLocal << dbParams;

    // Create the asyn parameter
    createParam(regType, rp.paramName.c_str(), rp.paramType, &paramIndex);

    // Create the record
    dbLoadRecords(rp.recTemplate.c_str(), dbParamsLocal.str().c_str());

    // Write the record name to the PV list file
    pvDumpFile->write("%s%*s", rp.recName.c_str(), recordNameLenMax - rp.recName.size() + 4, "");
    pvDumpFile->write("# %s (%s)\n", getNameWithoutLeafIndexes(p).c_str(), regInterfaceTypeNames[regType]);

    // Increment the number of created records
    ++recordCount;

    // Return the parameter index
    return paramIndex;
}

//////////////////////////////////////
// + template <typename T>          //
//   int getRegType(const T& reg);  //
//                                  //
// - Get the register type          //
//////////////////////////////////////
template <>
int YCPSWASYN::getRegType(const ScalVal_RO& reg)
{
    return DEV_REG_RO;
}

template <>
int YCPSWASYN::getRegType(const ScalVal& reg)
{
    return DEV_REG_RW;
}

template <>
int YCPSWASYN::getRegType(const DoubleVal_RO& reg)
{
    return DEV_FLOAT_RO;
}

template <>
int YCPSWASYN::getRegType(const DoubleVal& reg)
{
    return DEV_FLOAT_RW;
}

template <>
int YCPSWASYN::getRegType(const Command& reg)
{
    return DEV_CMD;
}

template <>
int YCPSWASYN::getRegType(const Stream& reg)
{
    return DEV_STM;
}
//////////////////////////////////////
// - template <typename T>          //
//   int getRegType(const T& reg);  //
//////////////////////////////////////


/////////////////////////////////////////////////////////////////
// + template <typename T>                                     //
//   void pushParameter(const T& reg, const int& parmaIndex);  //
//                                                             //
// - Push the register pointer to its respective list based    //
//   on the parameter index                                    //
/////////////////////////////////////////////////////////////////
template <>
void YCPSWASYN::pushParameter(const ScalVal_RO& reg, const int& paramIndex)
{
    ro[paramIndex] = reg;
    nRO++;
}

template <>
void YCPSWASYN::pushParameter(const ScalVal& reg, const int& paramIndex)
{
    rw[paramIndex] = reg;
    nRW++;
}

template <>
void YCPSWASYN::pushParameter(const DoubleVal_RO& reg, const int& paramIndex)
{
    fo[paramIndex] = reg;
    nFO++;
}

template <>
void YCPSWASYN::pushParameter(const DoubleVal& reg, const int& paramIndex)
{
    fw[paramIndex] = reg;
    nFW++;
}

template <>
void YCPSWASYN::pushParameter(const Command& reg, const int& paramIndex)
{
    cmd[paramIndex] = reg;
    nCMD++;
}

template <>
void YCPSWASYN::pushParameter(const Stream& reg, const int& paramIndex)
{
    nSTM++;
}
/////////////////////////////////////////////////////////////////
// - template <typename T>                                     //
//   void pushParameter(const T& reg, const int& parmaIndex);  //
/////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
// std::string YCPSWASYN::extractMbbxDbParams(const Enum& isEnum); //
//  - Extract record parameters related to MBBx records            //
/////////////////////////////////////////////////////////////////////
std::string YCPSWASYN::extractMbbxDbParams(const Enum& isEnum)
{

    int nValues = isEnum->getNelms();
    int mBits = ceil(log2(nValues));
    stringstream dbParamsLocal;

    dbParamsLocal.str("");
    dbParamsLocal << ",MASK=" << ((1 << mBits) - 1);
    dbParamsLocal << ",NOBT=" << mBits;

    IEnum::iterator it;
    int k;
    for (it = isEnum->begin(), k = 0 ; k < DB_MBBX_NELEM_MAX ; k++)
    {
        if (it != isEnum->end())
        {
            dbParamsLocal << "," << mbbxNameParams[k] << "=" << (*it).first->c_str();
            dbParamsLocal << "," << mbbxValParam[k] << "=" << (*it).second;
            ++it;
        }
        else
        {
            dbParamsLocal << "," << mbbxNameParams[k] << "=";
            dbParamsLocal << "," << mbbxValParam[k] << "=";
        }
    }

    return dbParamsLocal.str();
}

///////////////////////////////////////////////////////
// + template <typename T>                           //
//   int CreateRecord(const T& reg);                 //
//                                                   //
// - Create a record from a register pointer         //
///////////////////////////////////////////////////////
template <typename T>
int YCPSWASYN::CreateRecord(const T& reg)
{
    string dbParams;
    stringstream pName;
    int paramIndex;

    // Get the path to the register
    Path p = reg->getPath();

    // Get the child at the tail
    Child c = p->tail();

    // Get the register type
    int regType = getRegType(reg);
    int arrType;

    // Get the register information
    long nBits = reg->getSizeBits();
    Enum isEnum = reg->getEnum();
    int nElements = reg->getNelms();
    double scan = reg->getPollSecs();

    // Create the argument list used when loading the record
    recordParams trp;
    // + record name (and read back PV name if any)
    if (regType == DEV_REG_RW)
    {
        trp.recName = YCPSWASYN::generateRecordName(p, "St");
        dbParams += ",R_RBV=" + YCPSWASYN::generateRecordName(p, "Rd");
    }
    else
        trp.recName = YCPSWASYN::generateRecordName(p, "Rd");
    // + parameter name
    pName.str("");
    pName << string(c->getName()).substr(0, 10) << recordCount;
    trp.paramName = pName.str();
    // + record description field
    trp.recDesc = string("\"") + string(c->getDescription()).substr(0, DB_DESC_LENGTH_MAX) + string("\"");

    // Add the SCAN parameter base on the YAML pollSecs parameter to input registers
    if (regType == DEV_REG_RO)
        dbParams += getEpicsScan(scan);

    // Look trough the register properties and create the appropriate record type
    if ((!isEnum) || (isEnum->getNelms() > DB_MBBX_NELEM_MAX))
    {
        if (nElements == 1)
        {
            // Create longx record
            trp.paramType = asynParamInt32;
            arrType       = REG_SINGLE;
        }
        else
        {
            // Create waveform record
            stringstream dbParamsLocal;
            dbParamsLocal.str("");
            dbParamsLocal << ",N=" << reg->getNelms();
            dbParams += dbParamsLocal.str();

            if (nBits == 8)
            {
                // Create waveform_8_x record
                trp.paramType = asynParamOctet;
                arrType       = IScalVal_Base::ASCII == reg->getEncoding() ? REG_STRING : REG_ARRAY_8;
            }
            else
            {
                // Create waveform_x record
                trp.paramType = asynParamInt32Array;
                arrType       = REG_ARRAY;

            }
        }
        trp.recTemplate = templateList[regType][arrType];
        paramIndex      = LoadRecord(regType, trp, dbParams, p);
        pushParameter(reg, paramIndex);
    }
    else
    {
        arrType = REG_ENUM;
        if (nElements == 1)
        {
            // Create mbbx record
            dbParams += extractMbbxDbParams(isEnum);

            trp.paramType = asynParamUInt32Digital;
            trp.recTemplate = templateList[regType][arrType];

            paramIndex = LoadRecord(regType, trp, dbParams, p);
            pushParameter(reg, paramIndex);

        }
        else
        {
            // Create array of mbbx records
            stringstream index_aux;
            string c_name;
            Path pClone = p->clone();
            pClone->up();

            for (int j = 0 ; j < nElements ; j++)
            {
                index_aux.str("");
                index_aux << j;

                c_name.clear();
                c_name = c->getName() + string("[") + index_aux.str() + string("]");
                Path c_path = pClone->findByName(c_name.c_str());
                T c_reg = IScalVal::create(c_path);

                if (regType == DEV_REG_RW)
                {
                    trp.recName = YCPSWASYN::generateRecordName(c_path, "St");
                    dbParams += ",R_RBV=" + YCPSWASYN::generateRecordName(c_path, "Rd");
                }
                else
                    trp.recName = YCPSWASYN::generateRecordName(c_path, "Rd");

                pName.str("");
                pName << string(c->getName()).substr(0, 10) << recordCount;
                trp.paramName = pName.str();

                Enum isEnumLocal = c_reg->getEnum();

                dbParams += extractMbbxDbParams(isEnumLocal);

                trp.paramType = asynParamUInt32Digital;
                trp.recTemplate = templateList[regType][arrType];

                paramIndex = LoadRecord(regType, trp, dbParams, p);
                pushParameter(c_reg, paramIndex);
            }
        }
    }

    return (arrType << 8) | regType;
}
///////////////////////////////////////////////////////
// - template <typename T>                           //
//   int CreateRecord(const T& reg);                 //
///////////////////////////////////////////////////////

///////////////////////////////////////////////////////
// + template <typename T>                           //
//   int CreateRecord(const T& reg, const Path& p);  //
//                                                   //
//  - Create a record from a register pointer and    //
//     its path. This is for Command and Stream      //
//     which don't support the getPath() function    //
///////////////////////////////////////////////////////
template <>
int YCPSWASYN::CreateRecord(const Command& reg, const Path& p_)
{
    //Path p = reg->getPath();  // NOTE: Command/Stream don't support getPath() as ScalVal does.
                                // Workaround: using overloaded function with argument  Path p.
    Path p = p_->clone();
    Child c = p->tail();
    int regType = getRegType(reg);
    int arrType = REG_SINGLE;

    string dbParams;
    int paramIndex;
    stringstream pName;

    // Create the argument list used when loading the record
    recordParams trp;
    // + record name
    trp.recName = YCPSWASYN::generateRecordName(p, "Ex");
    // + parameter name
    pName.str("");
    pName << string(c->getName()).substr(0, 10) << recordCount;
    trp.paramName = pName.str();
    // + record description field
    trp.recDesc = string("\"") + string(c->getDescription()).substr(0, DB_DESC_LENGTH_MAX) + string("\"");
    // + parameter type
    trp.paramType = asynParamUInt32Digital;
    // + record template
    trp.recTemplate = templateList[regType][arrType];

    // BO record fields
    dbParams.clear();
    dbParams  = std::string(",MASK=1");
    dbParams += std::string(",ONAM=\"Run\"");
    dbParams += std::string(",ZNAM=\"Run\"");

    paramIndex = LoadRecord(regType, trp, dbParams, p);
    pushParameter(reg, paramIndex);

    return (arrType << 8) | regType;
}

template <>
int YCPSWASYN::CreateRecord(const Stream& reg, const Path& p_)
{

    //Path p = reg->getPath();  // NOTE: Command/Stream don't support getPath() as ScalVal does.
                                // Workaround: using overloaded function with argument  Path p.
    Path p = p_->clone();
    Child c = p->tail();
    int regType = getRegType(reg);

    string dbParams;
    int p16StmIndex, p32stmIndex;
    stringstream pName;

    // Create PVs for 32-bit stream data
    // Create the argument list used when loading the record
    recordParams trp;
    // + record name
    trp.recName = YCPSWASYN::generateRecordName(p, "32");
    dbParams += ",R_SA=" + YCPSWASYN::generateRecordName(p, "SL");
    // + parameter name
    pName.str("");
    pName << string(c->getName()).substr(0, 10) << recordCount;
    trp.paramName = pName.str();
    // + record description field
    trp.recDesc = string("\"") + string(c->getDescription()).substr(0, DB_DESC_LENGTH_MAX) + string("\"");
    // + parameter type
    trp.paramType = asynParamInt32;
    // + record template
    trp.recTemplate = templateListWaforms[WF_32_BIT];

    p32stmIndex = LoadRecord(regType, trp, dbParams, p);


    // Create PVs for 16-bit stream data
    dbParams.clear();
    // + record name
    trp.recName = YCPSWASYN::generateRecordName(p, "16");
    dbParams += ",R_SA=" + YCPSWASYN::generateRecordName(p, "SS");
    // + parameter name
    pName.str("");
    pName << string(c->getName()).substr(0, 10) << recordCount;
    trp.paramName = pName.str();
    // + parameter type
    trp.paramType = asynParamInt32;
    // + record template
    trp.recTemplate = templateListWaforms[WF_16_BIT];

    p16StmIndex = LoadRecord(regType, trp, dbParams, p);

    // Create Acquisition Thread
    asynStatus status;
    ThreadArgs *arglist = new ThreadArgs();
    arglist->pPvt = this;
    arglist->stm = reg;
    arglist->param16index = p16StmIndex;
    arglist->param32index = p32stmIndex;
    status = (asynStatus)(epicsThreadCreate("Stream", epicsThreadPriorityLow,
            epicsThreadGetStackSize(epicsThreadStackMedium), (EPICSTHREADFUNC)streamTaskC, arglist) == NULL);

    if (status)
    {
        printf("epicsThreadCreate failure for stream %s\n", p->toString().c_str());
        delete arglist;
        return -1;
    }
    else
        printf("epicsThreadCreate successfully for stream %s\n", p->toString().c_str());

    nSTM++;

    return (REG_STREAM << 8) | regType;
}
///////////////////////////////////////////////////////
// - template <typename T>                           //
//   int CreateRecord(const T& reg, const Path& p);  //
///////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////
// + template <typename T>                                 //
//   int CreateRecordFloat(const T& reg);                  //
//                                                         //
// - Create a record from a float register pointer         //
/////////////////////////////////////////////////////////////
template <typename T>
int YCPSWASYN::CreateRecordFloat(const T& reg)
{
    string dbParams;
    stringstream pName;
    int paramIndex;

    // Get the path to the register
    Path p = reg->getPath();

    // Get the child at the tail
    Child c = p->tail();

    // Get the register type
    int regType = getRegType(reg);
    int arrType;

    // Get the register information
    int nElements = reg->getNelms();
    double scan = reg->getPollSecs();

    // Create the argument list used when loading the record
    recordParams trp;
    // + record name (and read back PV name if any)
    if (regType == DEV_FLOAT_RW)
    {
        trp.recName = YCPSWASYN::generateRecordName(p, "St");
        dbParams += ",R_RBV=" + YCPSWASYN::generateRecordName(p, "Rd");
    }
    else
        trp.recName = YCPSWASYN::generateRecordName(p, "Rd");
    // + parameter name
    pName.str("");
    pName << string(c->getName()).substr(0, 10) << recordCount;
    trp.paramName = pName.str();
    // + record description field
    trp.recDesc = string("\"") + string(c->getDescription()).substr(0, DB_DESC_LENGTH_MAX) + string("\"");

    // Add the SCAN parameter base on the YAML pollSecs parameter to input registers
    if (regType == DEV_FLOAT_RO)
        dbParams += getEpicsScan(scan);

    // Look trough the register properties and create the appropriate record type
    if (nElements == 1)
    {
        // Create ax record
        trp.paramType = asynParamFloat64;
        arrType       = REG_SINGLE;
    }
    else
    {
        // Create waveform record
        stringstream dbParamsLocal;
        dbParamsLocal.str("");
        dbParamsLocal << ",N=" << reg->getNelms();
        dbParams += dbParamsLocal.str();
        trp.paramType = asynParamFloat64Array;
        arrType       = REG_ARRAY;
    }
    trp.recTemplate = templateList[regType][arrType];
    paramIndex = LoadRecord(regType, trp, dbParams, p);
    pushParameter(reg, paramIndex);

    return (arrType << 8) | regType;
}

int YCPSWASYN::CreateRecord(Path p2)
{
    ScalVal         rw_aux;
    ScalVal_RO      ro_aux;
    Command         cmd_aux;
    DoubleVal       fw_aux;
    DoubleVal_RO    fo_aux;
    Stream          stm_aux;
    int             rval = -1;
    bool            interfaceAttached = false;

    // Try to attach a ScalVal_RO and ScalVal interface
    try
    {
        ro_aux = IScalVal_RO::create(p2);
        interfaceAttached = true;
        rw_aux = IScalVal::create(p2);
    }
    catch (CPSWError &e)
    {
    }

    // If not interface was attached, try to attached a DoubleVal[_RO] interface
    if (!interfaceAttached)
    {
        try
        {
            fo_aux = IDoubleVal_RO::create(p2);
            interfaceAttached = true;
            fw_aux = IDoubleVal::create(p2);
        }
        catch (CPSWError &e)
        {
        }
    }

    // If not interface was attached, try to attached a Command interface
    if (!interfaceAttached)
    {
        try
        {
            cmd_aux = ICommand::create(p2);
            interfaceAttached = true;
        }
        catch (CPSWError &e)
        {
        }
    }

    // If not interface was attached, try to attached a Stream interface is the leaf name contains "Stream"
    if (!interfaceAttached)
    {
        if ( (std::string(p2->tail()->getName())).find(STREAM_KEY) !=  std::string::npos )
        {
            try
            {
                stm_aux = IStream::create(p2);
            }
            catch (CPSWError &e)
            {
            }
        }
    }

    // Depending on the attached interface, create a record for it
    if (ro_aux)
        rval = YCPSWASYN::CreateRecord(ro_aux);

    if (rw_aux)
        rval = YCPSWASYN::CreateRecord(rw_aux);

    if (fo_aux)
        rval = YCPSWASYN::CreateRecordFloat(fo_aux);

    if (fw_aux)
        rval = YCPSWASYN::CreateRecordFloat(fw_aux);

    if (cmd_aux)
        rval = YCPSWASYN::CreateRecord(cmd_aux, p2);

    if (stm_aux)
        rval = YCPSWASYN::CreateRecord(stm_aux, p2);

    return rval;
}

/////////////////////////////////////////////////////////////
// - template <typename T>                                 //
//   int CreateRecordFlorat(const T& reg);                 //
/////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
// std::string YCPSWASYN::generateRecordName(const Path& p, , const std::string& suffix); //
//                                                                                        //
// - Create the record name from its path                                                 //
////////////////////////////////////////////////////////////////////////////////////////////
std::string YCPSWASYN::generateRecordName(const Path& p, const std::string& suffix)
{
    std::string resultPrefix;

    // Auto-generation mode 2: generate hashed names
    if (autogenerationMode_ == 2)
    {
        char          mdstr[SHA1_HEX_SIZE];
        std::string   msg = recordPrefix_ + getNameWithoutLeafIndexes(p) + suffix;

        sha1 hasher( msg.c_str() );

        hasher.finalize().print_hex(mdstr);

        for (int i=0; i<SHA1_HEX_SIZE; i++ )
        {
            mdstr[i] = ::toupper(mdstr[i]);
        }
        resultPrefix = std::string(mdstr);

        // Return a truncated string (if necessary) to satisfy the record max length
        return resultPrefix.substr(0, recordNameLenMax);
    }

    Path pLocal = p->clone();
    Child tail;

    std::map<std::string, std::string>::iterator it;
    std::size_t found_bracket;
    bool found_key, found_top_key;
    std::string childName, childIndexStr;
    std::string pathStrAux, firstElementIndexStr;

    // First element (don't look it up on the map definitions)
    tail = pLocal->tail();

    if (!tail)
        return std::string();

    resultPrefix = tail->getName();

    // Look for the array index, if any
    pathStrAux = pLocal->toString();
    if (*pathStrAux.rbegin() == ']')
    {
        found_bracket = pathStrAux.find_last_of('[');
        firstElementIndexStr = pathStrAux.substr(found_bracket + 1 ,  pathStrAux.length() - found_bracket - 2);

        // Omit if it is a range instead of a single element
        if (firstElementIndexStr.find('-') != std::string::npos)
            firstElementIndexStr.clear();
    }

    // Continue with rest of the path
    pLocal->up();
    while (tail = pLocal->tail())
    {
        found_top_key = false;
        found_key = false;
        found_bracket = std::string::npos;
        childIndexStr.clear();

        childName = tail->getName();

        // Look for the array index, if any
        pathStrAux = pLocal->toString();
        if (*pathStrAux.rbegin() == ']')
        {
            found_bracket = pathStrAux.find_last_of('[');
            childIndexStr = pathStrAux.substr(found_bracket + 1 , pathStrAux.length() - found_bracket - 2);
        }

        // Look for keys on the top map definition
        for (it = mapTop.begin(); it != mapTop.end(); ++it)
        {
            found_top_key = ( 0 == childName.compare(it->first) );

            if (found_top_key)
            {
                childName = it->second;
                break;
            }
        }

        // If key was not fount on opt map, look for keys on the map definition
        if (!found_top_key)
        {
            for (it = map.begin(); it != map.end(); ++it)
            {
                found_key = ( 0 == childName.compare(it->first) );

                if (found_key)
                {
                    childName = it->second;
                    break;
                }
            }
        }

        // If the current child name was not found either on the map or top map, trim the name
        // and write its name to the dump file
        if ( !( found_key || found_top_key ) )
        {
            keysNotFound->insert(childName);
            childName = childName.substr(0,DB_NAME_PATH_TRIM_SIZE);
        }

        // Update the prefix up to now
        resultPrefix = childName + childIndexStr + ":" + resultPrefix;

        // If we found a key on the top map, stop the creation of the prefix
        if ( found_top_key )
            break;

        // Go up one level con the path and continue
        pLocal->up();
    }

    // Truncated string (if necessary) to satisfy the record max length and adding the index to the first element if any
    // (record prefix length [ +1 from adding ':']) + (record name length) + (first element index length) + (record suffix length) <= record max length
    resultPrefix = resultPrefix.substr(0, recordNameLenMax - (recordPrefix_.length() + 1) - DB_NAME_SUFFIX_LENGHT - firstElementIndexStr.length()) + firstElementIndexStr;

    // Add the record name prefix and suffix
    resultPrefix += ":" + suffix;
    if ( recordPrefix_.length() > 0 )
        resultPrefix = recordPrefix_ + ":" + resultPrefix;

    return resultPrefix;
}

/////////////////////////////////////////
// void YCPSWASYN::loadConfiguration() //
//                                     //
// - Load configuration from YAML      //
/////////////////////////////////////////
void YCPSWASYN::loadConfiguration()
{
    std::ifstream loadFile;
    Path configPath;
    uint64_t entryCount;

    // Find the configuration root path
    try
    {
        configPath = p_->findByName(loadConfigRootPath.c_str());
    }
    catch (CPSWError &e)
    {
        // If unsuccessful, send error message, update status and return
        printf("CPSW Error: Root path for loading configuration \"%s\" not found\n", e.getInfo().c_str());
        setUIntDigitalParam(DEV_CONFIG, loadConfigStatusValue_, CONFIG_STAT_ERROR, PROCESS_CONFIG_MASK);
        return;
    }

    // Try to open file
    loadFile.open(loadConfigFileName.c_str());

    if (!loadFile.is_open())
    {
        // If unsuccessful, update status and return
        setUIntDigitalParam(DEV_CONFIG, loadConfigStatusValue_, CONFIG_STAT_ERROR, PROCESS_CONFIG_MASK);
        return;
    }

    // Once file is open, update status
    setUIntDigitalParam(DEV_CONFIG, loadConfigStatusValue_, CONFIG_STAT_PROCESSING, PROCESS_CONFIG_MASK);
    callParamCallbacks(DEV_CONFIG);

    // Load configuration
    try
    {
        YAML::Node conf(YAML::LoadFile(loadConfigFileName.c_str()));
        entryCount = configPath->loadConfigFromYaml(conf);

        // Update status
        if (entryCount)
            setUIntDigitalParam(DEV_CONFIG, loadConfigStatusValue_, CONFIG_STAT_SUCCESS, PROCESS_CONFIG_MASK);
        else
            setUIntDigitalParam(DEV_CONFIG, loadConfigStatusValue_, CONFIG_STAT_ERROR, PROCESS_CONFIG_MASK);

    }
    catch (CPSWError &e)
    {
        // If unsuccessful, send error message
        printf("CPSW Error writing the configuration: %s\n", e.getInfo().c_str());
        entryCount = 0;

        // Update status
        setUIntDigitalParam(DEV_CONFIG, loadConfigStatusValue_, CONFIG_STAT_ERROR, PROCESS_CONFIG_MASK);
    }

    // Print number of entries loaded
    printf("Number of entries loaded: %" PRIu64 "\n", entryCount);

    // Close file
    loadFile.close();
}

/////////////////////////////////////////
// void YCPSWASYN::saveConfiguration() //
//                                     //
// - Save configuration to YAML        //
/////////////////////////////////////////
void YCPSWASYN::saveConfiguration()
{
    std::ofstream saveFile;
    Path configPath;
    uint64_t entryCount;

    // Find the configuration root path
    try
    {
        configPath = p_->findByName(saveConfigRootPath.c_str());
    }
    catch (CPSWError &e)
    {
        // If unsuccessful, send error message, update status and return
        printf("CPSW Error: Root path for saving configuration \"%s\" not found\n", e.getInfo().c_str());
        setUIntDigitalParam(DEV_CONFIG, saveConfigStatusValue_, CONFIG_STAT_ERROR, PROCESS_CONFIG_MASK);
        return;
    }

    // Try to open file
    saveFile.open(saveConfigFileName.c_str());

    if (!saveFile.is_open())
    {
        // If unsuccessful, update status and return
        setUIntDigitalParam(DEV_CONFIG, saveConfigStatusValue_, CONFIG_STAT_ERROR, PROCESS_CONFIG_MASK);
        return;
    }

    // Once file is open, update status
    setUIntDigitalParam(DEV_CONFIG, saveConfigStatusValue_, CONFIG_STAT_PROCESSING, PROCESS_CONFIG_MASK);
    callParamCallbacks(DEV_CONFIG);

    // Save configuration
    YAML::Node n;
    try
    {
        entryCount = configPath->dumpConfigToYaml(n);

        // Update status
        if (entryCount)
            setUIntDigitalParam(DEV_CONFIG, saveConfigStatusValue_, CONFIG_STAT_SUCCESS, PROCESS_CONFIG_MASK);
        else
            setUIntDigitalParam(DEV_CONFIG, saveConfigStatusValue_, CONFIG_STAT_ERROR, PROCESS_CONFIG_MASK);

    }
    catch (CPSWError &e)
    {
        // If unsuccessful, send error message
        printf("CPSW Error reading the configuration: %s\n", e.getInfo().c_str());
        entryCount = 0;

        // Update status
        setUIntDigitalParam(DEV_CONFIG, saveConfigStatusValue_, CONFIG_STAT_ERROR, PROCESS_CONFIG_MASK);
    }

    // Write configuration to file
    saveFile << n << std::endl;

    // Print number of entries saved
    printf("Number of entries saved: %" PRIu64 "\n", entryCount);

    // Close file
    saveFile.close();
}

////////////////////////////////////////////////////////
// std::string YCPSWYAML::getEpicsScan(double scan)   //
//                                                    //
//  - Calculate the closest SCAN value for the EPICS  //
//    record from the YAML pollSecs value             //
////////////////////////////////////////////////////////
std::string YCPSWASYN::getEpicsScan(double scan)
{
    std::string scanStr;
    scanStr = std::string(",SCAN=");

    if ( scan < 0.0 )
        // application, i.e., we pick a default
        scan = defaultScan;

    if (scan == 0.0)
        scanStr += std::string("Passive");
    else if (scan <= 0.1)
        scanStr += std::string(".1 second");
    else if (scan <= 0.2)
        scanStr += std::string(".2 second");
    else if (scan <= 0.5)
        scanStr += std::string(".5 second");
    else if (scan <= 1.0)
        scanStr += std::string("1 second");
    else if (scan <= 2.0)
        scanStr += std::string("2 second");
    else if (scan <= 5.0)
        scanStr += std::string("5 second");
    else
        scanStr += std::string("10 second");

    return scanStr;
}

/////////////////////////////////////////////////////////////////////////////////////
// int YCPSWASYN::autogenerateDatabase()                                           //
// - Automatic generation of database from YAML definition                         //
//                                                                                 //
/////////////////////////////////////////////////////////////////////////////////////
int YCPSWASYN::autogenerateDatabase()
{
    // Create file names for the register and PV list dumps
    std::string pre                  = debugFilePath + std::string(this->portName_) + "_";
    if ( recordPrefix_.length() > 0 )
    {
        pre += string(recordPrefix_) + "_";
    }
    std::string pvDumpFileName       = pre + PV_DUMP_FILE_NAME;
    std::string keysNotFoundFileName = pre + KEYS_NOT_FOUND_FILE_NAME;

    // Mapping files are only need when auto generation is used in mode 1
    if (autogenerationMode_ == 1)
    {
        std::string mapFileName;
        std::string mapTopFileName;

        // Create file names for the substitution map list
        mapFileName = string(mapFilePath) + string(MAP_FILE_NAME);
        mapTopFileName = string(mapFilePath) + string(MAP_TOP_FILE_NAME);

        // Create the substitution maps
        std::ifstream mapFile;
        std::string key, subs;

        printf("Opening top map file \"%s\"... ", mapTopFileName.c_str());
        mapFile.open(mapTopFileName.c_str());
        if (mapFile.is_open())
        {
            printf("Done.\n");
            while(!mapFile.eof())
            {
                mapFile >> key >> subs;
                mapTop.insert(std::pair<std::string, std::string>(key, subs));
            }
            mapFile.close();
        }
        else
        {
            printf("Error!\n");
        }
        printf("Opening map file \"%s\"... ", mapFileName.c_str());
        mapFile.open(mapFileName.c_str());
        if (mapFile.is_open())
        {
            printf("Done.\n");
            while(!mapFile.eof())
            {
                mapFile >> key >> subs;
                map.insert(std::pair<std::string, std::string>(key, subs));
            }
            mapFile.close();
        }
        else
        {
            printf("Error!\n");
        }

        // Creating set of not found key object
        keysNotFound = new YCPSWKeysNotFound (keysNotFoundFileName);
    }

    // Open the PV list file
    printf("Opening file \"%s\" for dumping PV list.\n", pvDumpFileName.c_str());
    pvDumpFile  = new YCPSWASYNRAIIFile(pvDumpFileName, "w");

    // Generate the EPICS database from the root path
    printf("Generating EPICS database from yaml file...\n");
    try
    {
        YCPSWASYNGenerateDB generateDB( pre, this );

        generateDB.yamlFile.write( "recordPrefix: %s\nroot:\n", recordPrefix_.c_str() );
        generateDB.pushYamlIndent();
        generateDB.genereate( p_ );
        generateDB.popYamlIndent();
    }
    catch (CPSWError &e)
    {
        fprintf(stderr, "CPSW Error (during DB generation, port: %s): %s\n", this->portName_, e.getInfo().c_str());
    }

    printf("Generation of EPICS database from yaml file Done!.\n");

    if (autogenerationMode_ == 1)
    {
        // Dump the not found keys
        printf("Dumping not found keys into file %s\n", keysNotFoundFileName.c_str());
        keysNotFound->dump();
        delete keysNotFound;
    }

    // Close the PV list file
    delete pvDumpFile;

    // Print counters
    printf("Total number of record loaded = %ld\n", recordCount);
    printf("Total number of register processed:\n");
    printf("  - ScalVal_RO   = %ld\n", nRO - nRW);
    printf("  - ScalVal      = %ld\n", nRW);
    printf("  - DoubleVal_RO = %ld\n", nFO - nFW);
    printf("  - DoubleVal    = %ld\n", nFW);
    printf("  - Command      = %ld\n", nCMD);
    printf("  - Stream       = %ld\n", nSTM);
    printf("\n");

    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// void YCPSWASYN::addParameter(const T& reg, const std::string& paramName, const asynParamType& paramType) //
// - Creates a parameter for the given register an add its pointer to its list                              //
//                                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
void YCPSWASYN::addParameter(const T& reg, const std::string& paramName, const asynParamType& paramType)
{
    int paramIndex;

    createParam(getRegType(reg), paramName.c_str(), paramType, &paramIndex);
    pushParameter(reg, paramIndex);
}

template <>
void YCPSWASYN::addParameter(const Stream& reg, const std::string& paramName, const asynParamType& paramType)
{
    int paramIndex32, paramIndex16;
    std::string paramName16 = paramName + string(":16");

    createParam(DEV_STM, paramName.c_str(), paramType, &paramIndex32);
    createParam(DEV_STM, paramName16.c_str(), paramType, &paramIndex16);

    // Create Acquisition Thread
    asynStatus status;
    ThreadArgs *arglist = new ThreadArgs();
    arglist->pPvt = this;
    arglist->stm = reg;
    arglist->param16index = paramIndex16;
    arglist->param32index = paramIndex32;

    status = (asynStatus)(epicsThreadCreate("Stream", epicsThreadPriorityLow,
            epicsThreadGetStackSize(epicsThreadStackMedium), (EPICSTHREADFUNC)streamTaskC, arglist) == NULL);

    if (status)
    {
        printf("epicsThreadCreate failure for parameter %s\n", paramName.c_str());
        delete arglist;
        return;
    }
    else
        printf("epicsThreadCreate successfully for parameters %s and %s\n", paramName.c_str(), paramName16.c_str());

}

/////////////////////////////////////////////////////////////////////////////////////////
// void YCPSWASYN::createRegisterParameter(const T& reg, const std::string& paramName) //
// - Creates a asyn parameter for the given register                                   //
//                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
void YCPSWASYN::createRegisterParameter(const T& reg, const std::string& paramName)
{
    asynParamType paramType;

    // Get the register information
    int  nElements = reg->getNelms();
    Enum isEnum    = reg->getEnum();

    if (nElements == 1)
    {
        if ((isEnum) && (isEnum->getNelms() < DB_MBBX_NELEM_MAX))
            paramType = asynParamUInt32Digital;
        else
            paramType =  asynParamInt32;
    }
    else
    {
        paramType = asynParamInt32Array;
    }

    addParameter(reg, paramName, paramType);
}

template<>
void YCPSWASYN::createRegisterParameter(const Command& reg, const std::string& paramName)
{
    addParameter(reg, paramName, asynParamUInt32Digital);
}

template<>
void YCPSWASYN::createRegisterParameter(const Stream& reg, const std::string& paramName)
{
    addParameter(reg, paramName, asynParamInt32);
}

//////////////////////////////////////////////////////////////////////////////////////////////
// void YCPSWASYN::createRegisterParameterFloat(const T& reg, const std::string& paramName) //
// - Creates a asyn parameter for the given float register                                  //
//                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
void YCPSWASYN::createRegisterParameterFloat(const T& reg, const std::string& paramName)
{
    asynParamType paramType;

    // Get the register information
    int nElements = reg->getNelms();

    if (nElements == 1)
        paramType =  asynParamFloat64;
    else
        paramType = asynParamFloat64Array;

    addParameter(reg, paramName, paramType);
}

/////////////////////////////////////////////////////////////////////////////////////
// int YCPSWASYN::loadDBFromFile(const char* fileName)                             //
// - Load database from dictionary file                                            //
//                                                                                 //
/////////////////////////////////////////////////////////////////////////////////////
int YCPSWASYN::loadDBFromFile(const char* dictionary)
{
    if (dictionary && dictionary[0] != '\0')
    {
        printf("Opening dictionary \"%s\"... ", dictionary);
        std::ifstream dictFile;
        dictFile.open(dictionary);
        if (dictFile.is_open())
        {
            printf("Done.\n");
            std::string line;

            while (std::getline(dictFile, line))
            {
                std::istringstream iss(line);
                std::string regPath, paramName;

                iss >> regPath >> paramName;

                // Omit lines without both path and parameter name
                if (regPath.empty() || paramName.empty())
                    continue;

                // Omit comment lines, which start with '#'
                if (regPath[0] == '#')
                    continue;

                // Check first if it is a stream
                size_t found_key = regPath.find(STREAM_KEY);
                if ((found_key != std::string::npos) && (isdigit(regPath[found_key + strlen(STREAM_KEY)])))
                {
                    Stream stm_aux;

                    try
                    {
                        stm_aux = IStream::create(p_->findByName(regPath.c_str()));
                    }
                    catch (CPSWError &e) {}

                    if (stm_aux)
                    {
                        printf("Stream interface created for %s\n", regPath.c_str());
                        createRegisterParameter(stm_aux, paramName);
                    }
                    else
                    {
                        printf("ERROR: No access found for stream %s\n", regPath.c_str());
                    }

                }
                // Now try the other kind of interfaces
                else
                {
                    ScalVal         rw_aux;
                    ScalVal_RO      ro_aux;
                    Command         cmd_aux;
                    DoubleVal       fw_aux;
                    DoubleVal_RO    fo_aux;

                    try
                    {
                        ro_aux = IScalVal_RO::create(p_->findByName(regPath.c_str()));
                        rw_aux = IScalVal::create(p_->findByName(regPath.c_str()));
                    }
                    catch (CPSWError &e) {}

                    if (rw_aux)
                    {
                        printf("ScalVal interface created for %s\n", regPath.c_str());
                        createRegisterParameter(rw_aux, paramName);

                         // Temporary: This was added to ensure arrays of RW registers can be read back
                         if (rw_aux -> getNelms() > 1 && ro_aux)
                         {
                             printf("ScalVal_RO interface created for %s\n", regPath.c_str());
                             createRegisterParameter(ro_aux, paramName);
                         }
                    }
                    else if (ro_aux)
                    {
                        printf("ScalVal_RO interface created for %s\n", regPath.c_str());
                        createRegisterParameter(ro_aux, paramName);
                    }
                    else
                    {
                        try
                        {
                            fo_aux = IDoubleVal_RO::create(p_->findByName(regPath.c_str()));
                            fw_aux = IDoubleVal::create(p_->findByName(regPath.c_str()));
                        }
                        catch (CPSWError &e) {}

                        if (fw_aux)
                        {
                            printf("DoubleVal interface created for %s\n", regPath.c_str());
                            createRegisterParameterFloat(fw_aux, paramName);

                        }
                        else if (fo_aux)
                        {
                            printf("DoubleVal_RO interface created for %s\n", regPath.c_str());
                            createRegisterParameterFloat(fo_aux, paramName);
                        }
                        else
                        {
                            try
                            {
                                cmd_aux = ICommand::create(p_->findByName(regPath.c_str()));
                            }
                            catch (CPSWError &e) {}

                            if (cmd_aux)
                            {
                                printf("Command interface created for %s\n", regPath.c_str());
                                createRegisterParameter(cmd_aux, paramName);
                            }
                            else
                            {
                                // ERROR
                                printf("ERROR: No access found to register %s\n", regPath.c_str());
                            }
                        }
                    }

                }
            }
            dictFile.close();
            printf("Dictionary processed\n");
        }
        else
        {
            printf("Error! Ignoring file\n");
        }
    }

    return 0;
}

//////////////////////////////////////////////
// + Methods overridden from asynPortDriver //
//////////////////////////////////////////////
asynStatus YCPSWASYN::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    const char *name;

    this->getAddress(pasynUser, &addr);

    static const char *functionName = "writeInt32";

    this->getAddress(pasynUser, &addr);

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_REG_RW)
                rw[function]->setVal((uint32_t*)&value, 1);
            else if (addr == DEV_CONFIG)
            {
                if (function == saveConfigValue_)
                    saveConfiguration();
                else if (function == loadConfigValue_)
                    loadConfiguration();
                else
                    status = asynPortDriver::writeInt32(pasynUser, value);
            }
            else
                status = asynPortDriver::writeInt32(pasynUser, value);
        }
        catch (CPSWError &e)
        {
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }



        if (status == 0)
        {
            asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                        "%s:%s(%d), port %s parameter %s set to %d\n", \
                        driverName_, functionName, function, this->portName, name, value);
        }
        else
        {
            asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                        "%s:%s(%d), port %s ERROR setting parameter %s to %d (status = %d)\n", \
                        driverName_, functionName, function, this->portName, name, value, status);
        }

    }
    else
        status = asynPortDriver::writeInt32(pasynUser, value);

    callParamCallbacks(addr);
    unlock();

    return (status==0) ? asynSuccess : asynError;
}

asynStatus YCPSWASYN::readInt32(asynUser *pasynUser, epicsInt32 *value)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    uint32_t u32;
    const char *name;

    this->getAddress(pasynUser, &addr);

    static const char *functionName = "readInt32";

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_REG_RO)
            {
                ro[function]->getVal(&u32, 1);
                *value = (epicsInt32)u32;
                status = setIntegerParam(addr, function, (int)u32);
            }
            else if (addr == DEV_REG_RW)
            {
                rw[function]->getVal(&u32, 1);
                *value = (epicsInt32)u32;
                status = setIntegerParam(addr, function, (int)u32);
            }
            else if (addr == DEV_CONFIG)
            {
                status = getIntegerParam(addr, function, (int*)value);
            }
            else
                status = asynPortDriver::readInt32(pasynUser, value);
        }
        catch (CPSWError &e)
        {
            status = -1;
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }
    }
    else
        status = asynPortDriver::readInt32(pasynUser, value);

    if (status == 0)
    {
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                    "%s:%s(%d), port %s read %d from parameter %s\n", \
                    driverName_, functionName, function, this->portName, *value, name);
    }
    else
    {
        asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                    "%s:%s(%d), port %s ERROR reading parameter %s (status = %d)\n", \
                    driverName_, functionName, function, this->portName, name, status);
    }

    callParamCallbacks(addr);
    unlock();

    return (status==0) ? asynSuccess : asynError;
}


asynStatus YCPSWASYN::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    const char *name;

    this->getAddress(pasynUser, &addr);

    static const char *functionName = "writeFloat64";

    this->getAddress(pasynUser, &addr);

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_FLOAT_RW)
                fw[function]->setVal((double*)&value, 1);
            else
                status = asynPortDriver::writeFloat64(pasynUser, value);
        }
        catch (CPSWError &e)
        {
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }

        if (status == 0)
        {
            asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                        "%s:%s(%d), port %s parameter %s set to %f\n", \
                        driverName_, functionName, function, this->portName, name, value);
        }
        else
        {
            asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                        "%s:%s(%d), port %s ERROR setting parameter %s to %f (status = %d)\n", \
                        driverName_, functionName, function, this->portName, name, value, status);
        }

    }
    else
        status = asynPortDriver::writeFloat64(pasynUser, value);

    callParamCallbacks(addr);
    unlock();

    return (status==0) ? asynSuccess : asynError;
}

asynStatus YCPSWASYN::readFloat64(asynUser *pasynUser, epicsFloat64 *value)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    double val;
    const char *name;

    this->getAddress(pasynUser, &addr);

    static const char *functionName = "readFloat64";

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_FLOAT_RO)
            {
                fo[function]->getVal(&val, 1);
                *value = (epicsFloat64)val;
                setDoubleParam(addr, function, val);
            }
            else if (addr == DEV_FLOAT_RW)
            {
                fw[function]->getVal(&val, 1);
                *value = (epicsFloat64)val;
                setDoubleParam(addr, function, val);;
            }
            else
                status = asynPortDriver::readFloat64(pasynUser, value);
        }
        catch (CPSWError &e)
        {
            status = -1;
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }
    }
    else
        status = asynPortDriver::readFloat64(pasynUser, value);

    if (status == 0)
    {
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                    "%s:%s(%d), port %s read %f from parameter %s\n", \
                    driverName_, functionName, function, this->portName, *value, name);
    }
    else
    {
        asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                    "%s:%s(%d), port %s ERROR reading parameter %s (status = %d)\n", \
                    driverName_, functionName, function, this->portName, name, status);
    }

    callParamCallbacks(addr);
    unlock();

    return (status==0) ? asynSuccess : asynError;
}

asynStatus YCPSWASYN::writeInt32Array(asynUser *pasynUser, epicsInt32 *value, size_t nElements)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    size_t n = 0;
    const char *name;
    static const char *functionName = "writeInt32Array";
    IndexRange range(0, nElements-1);

    this->getAddress(pasynUser, &addr);

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_REG_RW)
                n = rw[function]->setVal((uint32_t*)value, nElements, &range);
            else
                status = asynPortDriver::writeInt32Array(pasynUser, value, nElements);
        }
        catch (CPSWError &e)
        {
            status = -1;
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }
    }
    else
        status = asynPortDriver::writeInt32Array(pasynUser, value, nElements);

    if (status == 0)
    {
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                    "%s:%s(%d), port %s set new content on parameter %s. Requested = %zu, written = %zu\n", \
                    driverName_, functionName, function, this->portName, name, nElements, n);
    }
    else
    {
        asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                    "%s:%s(%d), port %s ERROR setting parameter %s. Requested = %zu (status = %d)\n", \
                    driverName_, functionName, function, this->portName, name, nElements, status);
    }

    callParamCallbacks(addr);
    unlock();

    return (status==0) ? asynSuccess : asynError;

}

asynStatus YCPSWASYN::readInt32Array(asynUser *pasynUser, epicsInt32 *value, size_t nElements, size_t *nIn)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    const char *name;
    static const char *functionName = "readInt32Array";
    this->getAddress(pasynUser, &addr);
    uint64_t buffer[nElements];

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_REG_RO)
            {
                ro[function]->getVal(buffer, nElements);
                std::copy(buffer, buffer+nElements, value);
                *nIn = nElements;
            }
            else if (addr == DEV_REG_RW)
            {
                rw[function]->getVal(buffer, nElements);
                std::copy(buffer, buffer+nElements, value);
                *nIn = nElements;
            }
            else
                status = asynPortDriver::readInt32Array(pasynUser, value, nElements, nIn);
        }
        catch (CPSWError &e)
        {
            status = -1;
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }
    }
    else
        status = asynPortDriver::readInt32Array(pasynUser, value, nElements, nIn);

    if (status == 0)
    {
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                    "%s:%s(%d), port %s got parameter %s, requested = %zu, got = %zu\n", \
                    driverName_, functionName, function, this->portName, name, nElements, *nIn);
    }
    else
    {
        asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                    "%s:%s(%d), port %s ERROR getting  parameter %s. Requested = %zu (status = %d)\n", \
                    driverName_, functionName, function, this->portName, name, nElements, status);
    }

    callParamCallbacks(addr);
    unlock();

    return (status==0) ? asynSuccess : asynError;
}

asynStatus YCPSWASYN::readOctet(asynUser *pasynUser, char *value, size_t maxChars, size_t *nActual, int *eomReason)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    const char *name;
    static const char *functionName = "readOctet";
    uint8_t buffer[maxChars];
    this->getAddress(pasynUser, &addr);

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_REG_RO)
            {
                ro[function]->getVal(buffer, maxChars);
                std::copy(buffer, buffer+maxChars, value);
                *nActual = maxChars;
            }
            else if (addr == DEV_REG_RW)
            {
                rw[function]->getVal(buffer, maxChars);
                std::copy(buffer, buffer+maxChars, value);
                *nActual = maxChars;
            }
            else
                status = asynPortDriver::readOctet(pasynUser, value, maxChars, nActual, eomReason);
        }
        catch (CPSWError &e)
        {
            status = -1;
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }
    }
    else
        status = asynPortDriver::readOctet(pasynUser, value, maxChars, nActual, eomReason);

    if (status == 0)
    {
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                    "%s:%s(%d), port %s maxChars = %zu, nActual = %zu, eomReason %d\n", \
                    driverName_, functionName, function, this->portName, maxChars, *nActual, *eomReason);
    }
    else
    {
        asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                    "%s:%s(%d), port %s ERROR getting parameter %s. Requested = %zu (status = %d)\n", \
                    driverName_, functionName, function, this->portName, name, maxChars, status);
    }

    callParamCallbacks(addr);
    unlock();

    return (status==0) ? asynSuccess : asynError;
}

asynStatus YCPSWASYN::writeOctet (asynUser *pasynUser, const char *value, size_t maxChars, size_t *nActual)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    const char *name;
    static const char *functionName = "writeOctet";
    this->getAddress(pasynUser, &addr);
    IndexRange range(0, maxChars-1);

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_REG_RW)
            {
                *nActual = (size_t)rw[function]->setVal((uint8_t*)value, maxChars, &range);
                if (*nActual <= 0)
                        status = -1;
            }
            else if (addr == DEV_CONFIG)
            {
                if (function == saveConfigFileValue_)
                {
                    saveConfigFileName = std::string(value);
                    *nActual = maxChars;
                    status = setStringParam(DEV_CONFIG, saveConfigFileValue_, value);
                }
                else if (function == loadConfigFileValue_)
                {
                    loadConfigFileName = std::string(value);
                    *nActual = maxChars;
                    status = setStringParam(DEV_CONFIG, loadConfigFileValue_, value);
                }
                else if (function == loadConfigRootValue_)
                {
                    loadConfigRootPath = std::string(value);
                    *nActual = maxChars;
                    status = setStringParam(DEV_CONFIG, loadConfigRootValue_, value);
                }
                else if (function == saveConfigRootValue_)
                {
                    saveConfigRootPath = std::string(value);
                    *nActual = maxChars;
                    status = setStringParam(DEV_CONFIG, saveConfigRootValue_, value);
                }
                else
                    status = writeOctet (pasynUser, value, maxChars, nActual);
            }
            else
                status = writeOctet (pasynUser, value, maxChars, nActual);
        }
        catch (CPSWError &e)
        {
            status = -1;
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }
    }
    else
        status = writeOctet (pasynUser, value, maxChars, nActual);

    if (status == 0)
    {
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                    "%s:%s(%d), port %s set new content on parameter %s. Requested = %zu, written = %zu\n", \
                    driverName_, functionName, function, this->portName, name, maxChars, *nActual);
    }
    else
    {
        asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                    "%s:%s(%d), port %s ERROR setting parameter %s. Requested = %zu (status = %d)\n", \
                    driverName_, functionName, function, this->portName, name, maxChars, status);
    }

    callParamCallbacks(addr);
    unlock();

    return (status==0) ? asynSuccess : asynError;
}


asynStatus YCPSWASYN::readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    uint64_t buffer[nElements];
    this->getAddress(pasynUser, &addr);
    const char *name;

    static const char *functionName = "readFloat64Array";

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_REG_RO)
            {
                ro[function]->getVal(buffer, nElements);
                std::copy(buffer, buffer+nElements, value);
                *nIn = nElements;
            }
            else if (addr == DEV_REG_RW)
            {
                rw[function]->getVal(buffer, nElements);
                std::copy(buffer, buffer+nElements, value);
                *nIn = nElements;
            }
            else
                status = asynPortDriver::readFloat64Array(pasynUser, value, nElements, nIn);
        }
        catch (CPSWError &e)
        {
            status = -1;
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }
    }
    else
        status = asynPortDriver::readFloat64Array(pasynUser, value, nElements, nIn);

    if (status == 0)
    {
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                    "%s:%s(%d), port %s get parameter %s. Requested = %zu, got = %zu\n", \
                    driverName_, functionName, function, this->portName, name, nElements, *nIn);
    }
    else
    {
        asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                    "%s:%s(%d), port %s ERROR getting parameter %s. Requested = %zu (status = %d)\n", \
                    driverName_, functionName, function, this->portName, name, nElements, status);
    }

    callParamCallbacks();
    unlock();

    return (status==0) ? asynSuccess : asynError;

}

asynStatus YCPSWASYN::writeFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    size_t n = 0;
    this->getAddress(pasynUser, &addr);
    const char *name;
    IndexRange range(0, nElements-1);

    static const char *functionName = "writeFloat64Array";

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_REG_RW)
                n = rw[function]->setVal((uint32_t*)value, nElements, &range);
            else
                status = asynPortDriver::writeFloat64Array(pasynUser, value, nElements);
        }
        catch (CPSWError &e)
        {
            status = -1;
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }
    }
    else
        status = asynPortDriver::writeFloat64Array(pasynUser, value, nElements);

    if (status == 0)
    {
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                    "%s:%s(%d), port %s set new content on parameter %s. Requested = %zu, written = %zu\n", \
                    driverName_, functionName, function, this->portName, name, nElements, n);
    }
    else
    {
        asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                    "%s:%s(%d), port %s ERROR setting parameter %s. Requested = %zu (status = %d)\n", \
                    driverName_, functionName, function, this->portName, name, nElements, status);
    }

    callParamCallbacks();
    unlock();

    return (status==0) ? asynSuccess : asynError;
}

asynStatus YCPSWASYN::writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    const char *name;
    epicsUInt32 val;

    this->getAddress(pasynUser, &addr);

    static const char *functionName = "writeUInt32Digital";

    this->getAddress(pasynUser, &addr);

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_REG_RW)
            {
                val &= ~mask;
                val |= value;
                rw[function]->setVal((uint32_t*)&val, 1);
            }
            else if(addr == DEV_CMD)
            {
                cmd[function]->execute();
            }
            else
                status = asynPortDriver::writeUInt32Digital(pasynUser, value, mask);
        }
        catch (CPSWError &e)
        {
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }
    }
    else
        status = asynPortDriver::writeUInt32Digital(pasynUser, value, mask);

    if (status == 0)
    {
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                    "%s:%s(%d), port %s parameter %s set to %d\n", \
                    driverName_, functionName, function, this->portName, name, value);
    }
    else
    {
        asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                    "%s:%s(%d), port %s ERROR setting parameter %s to %d (status = %d)\n", \
                    driverName_, functionName, function, this->portName, name, value, status);
    }

    callParamCallbacks(addr);
    unlock();

    return (status==0) ? asynSuccess : asynError;
}

asynStatus YCPSWASYN::readUInt32Digital(asynUser *pasynUser, epicsUInt32 *value, epicsUInt32 mask)
{
    int addr;
    int function = pasynUser->reason;
    int status=0;
    uint32_t u32;
    const char *name;

    this->getAddress(pasynUser, &addr);

    static const char *functionName = "readUInt32Digital";

    lock();
    if (!getParamName(addr, function, &name))
    {
        try
        {
            if (addr == DEV_REG_RO)
            {
                ro[function]->getVal(&u32, 1);
                u32 &= mask;
                *value = (epicsInt32)u32;
                status = setUIntDigitalParam(addr, function, (epicsUInt32)u32, mask);
            }
            else if (addr == DEV_REG_RW)
            {
                rw[function]->getVal(&u32, 1);
                u32 &= mask;
                *value = (epicsInt32)u32;
                status = setUIntDigitalParam(addr, function, (epicsUInt32)u32, mask);
            }
            else if (addr == DEV_CMD)
            {
                u32 = 0;
                *value = (epicsInt32)u32;
                status = setUIntDigitalParam(addr, function, (epicsUInt32)u32, mask);
            }
            else if (addr == DEV_CONFIG)
            {
                status = getUIntDigitalParam(addr, function, value, mask);
            }

            else
                status = asynPortDriver::readUInt32Digital(pasynUser, value, mask);
        }
        catch (CPSWError &e)
        {
            status = -1;
            asynPrint(pasynUser, ASYN_TRACE_ERROR, "CPSW Error (during %s, parameter: %s): %s\n", functionName, name, e.getInfo().c_str());
        }
    }
    else
        status = asynPortDriver::readUInt32Digital(pasynUser, value, mask);

    if (status == 0)
    {
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                    "%s:%s(%d), port %s read %d from parameter %s\n", \
                    driverName_, functionName, function, this->portName, *value, name);
    }
    else
    {
        asynPrint(pasynUser, ASYN_TRACE_ERROR, \
                    "%s:%s(%d), port %s ERROR reading parameter %s (status = %d)\n", \
                            driverName_, functionName, function, this->portName, name, status);
    }

    callParamCallbacks(addr);
    unlock();

    return (status==0) ? asynSuccess : asynError;
}

asynStatus YCPSWASYN::getBounds(asynUser *pasynUser, epicsInt32 *low, epicsInt32 *high)
{
    int addr;
    int status = 0;
    int function = pasynUser->reason;
    this->getAddress(pasynUser, &addr);
    const char *name;
    static const char *functionName = "getBounds";

    if (!getParamName(addr, function, &name))
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, \
                    "%s:%s(%d), port %s getRegister %s\n", \
                    driverName_, functionName, function, this->portName, name);

    status = asynPortDriver::getBounds(pasynUser, low, high);

    return (status==0) ? asynSuccess : asynError;

}


void YCPSWASYN::report(FILE *fp, int details)
{
    fprintf(fp, "  Port: %s\n", this->portName);
    asynPortDriver::report(fp, details);
}

YCPSWASYNRAIIFile::YCPSWASYNRAIIFile(const std::string &name, const char *mode)
    :
    name_(name)
{
    if ( ! (f_ = fopen( name.c_str(), mode )) )
    {
        printf("ERROR: Unable to open file: %s\n", name.c_str());
    }
}

void YCPSWASYNRAIIFile::write(const char * format, ...)
{
    if (f_ != NULL)
        fprintf(f_, format);
}

YCPSWASYNRAIIFile::~YCPSWASYNRAIIFile()
{
    if (f_ != NULL)
        fclose( f_ );
}

YCPSWASYNGenerateDB::YCPSWASYNGenerateDB(const std::string &pre, YCPSWASYN *drv)
    :
    drv_   ( drv ),
    indent_( 0   ),
    textFile( YCPSWASYNRAIIFile( pre + REG_DUMP_TEXT_FILE_NAME, "w" ) ),
    yamlFile( YCPSWASYNRAIIFile( pre + REG_DUMP_YAML_FILE_NAME, "w" ) )

{
}

bool YCPSWASYNGenerateDB::visitPre(ConstPath p)
{
    std::string rep = p->toString();
    const char *lst = strrchr( rep.c_str(), '/' );
    int         type;

    lst = lst ? lst + 1 : rep.c_str();
    yamlFile.write("%*s%s:", yamlIndent(), "", lst);
    if ( ! p->tail()->isHub() )
    {
        type = drv_->CreateRecord( p->clone() );
        enum registerInterfaceTypeList ifType( static_cast<enum registerInterfaceTypeList>(type & 0xff) );
        enum regTypeList               rgType( static_cast<enum regTypeList>         ((type>>8) & 0xff) );
        yamlFile.write(" \"%s,%s\"", regInterfaceTypeNames[ifType], regTypeNames[rgType]);
        textFile.write("%s\n", p->toString().c_str());
    }
    yamlFile.write("\n");
    pushYamlIndent();
    return true;
}

void YCPSWASYNGenerateDB::visitPost(ConstPath p)
{
    popYamlIndent();
}

void YCPSWASYNGenerateDB::processStack(unsigned level)
{
    unsigned i, t;

    if  ( pathStack_[level]->empty() )
    {
        // Process empty paths, (i.e. paths starting at root)
        pathStack_[level]->explore( this );
    }
    else
    {
        for ( i = pathStack_[level]->getTailFrom(); i <= (t = pathStack_[level]->getTailTo()); i++ )
        {
            if ( pathStack_[level]->tail()->getNelms() == 1 )
            {
                snprintf(idx_, sizeof(idx_), "%s", pathStack_[level]->tail()->getName());
            }
            else
            {
                snprintf(idx_, sizeof(idx_), "%s[%d]", pathStack_[level]->tail()->getName(), i);
            }

            if ( level == 0 )
            {
                // explore already expands the last level of the prefix
                if ( t != i )
                {
                    snprintf(idx_, sizeof(idx_), "%s[%d-%d]", pathStack_[level]->tail()->getName(), i, t);
                }
                workingPrefix_->findByName( idx_ )->explore( this );
                return;
            }

            yamlFile.write("%*s%s:\n", yamlIndent(), "", idx_ );
            workingPrefix_ = workingPrefix_->findByName( idx_ );
            pushYamlIndent();
                processStack( level - 1 );
            popYamlIndent();
            workingPrefix_->up();
        }
    }
}

void YCPSWASYNGenerateDB::genereate(Path p)
{
    workingPrefix_ = p->clone();

    do
    {
        pathStack_.push_back( workingPrefix_ );
        workingPrefix_ = workingPrefix_->clone();
        workingPrefix_->up();
    }
    while ( ! workingPrefix_->empty() );

    processStack( pathStack_.size() - 1 );
}

YCPSWKeysNotFound::YCPSWKeysNotFound(const std::string &fileName)
    :
    fileName_(fileName)
{
}

void YCPSWKeysNotFound::insert(const std::string &element)
{
    list_.insert(element);
}

void YCPSWKeysNotFound::dump()
{
    YCPSWASYNRAIIFile f (YCPSWASYNRAIIFile(fileName_, "w"));

    if (f.f())
    {
        for (std::set<std::string>::iterator it = list_.begin() ; it != list_.end() ; ++it )
            f.write("%s\n", (*it).c_str());
    }
}

// Remove '[a-b]' of the name when leaf are arrays
std::string getNameWithoutLeafIndexes(const Path& p)
{
    std::string s(p->toString());
    if (*s.rbegin() == ']')
        s.erase(s.find_last_of('['));

    return s;
}

//////////////////////////////////////////////
// - Methods overridden from asynPortDriver //
//////////////////////////////////////////////

////////////////////////////////////
// Driver configuration functions //
////////////////////////////////////

// YCPSWASYNConfig
extern "C" int YCPSWASYNConfig(const char *portName, const char *rootPath, const char *recordPrefix, int autogenerationMode, const char* dictionary, const char* namedRoot)
{
    int status;
    Path p;

    status = YCPSWASYN::YCPSWASYNInit(rootPath, &p, namedRoot);

    if (status)
    {
        printf("ERROR! YCPSWASYNInit failed with error code: %d\n\n", status);
        return asynError;
    }

    new YCPSWASYN(portName, p, recordPrefix, autogenerationMode, dictionary);

    return (status==0) ? asynSuccess : asynError;
}

static const iocshArg confArg0 =    { "portName",           iocshArgString };
static const iocshArg confArg1 =    { "rootPath",           iocshArgString };
static const iocshArg confArg2 =    { "recordPrefix",       iocshArgString };
static const iocshArg confArg3 =    { "autoGenerationMode", iocshArgInt    };
static const iocshArg confArg4 =    { "loadDictionary",     iocshArgString };
static const iocshArg confArg5 =    { "namedRoot",          iocshArgString };

static const iocshArg * const confArgs[] =
{
    &confArg0,
    &confArg1,
    &confArg2,
    &confArg3,
    &confArg4,
    &confArg5
};

static const iocshFuncDef configFuncDef = {"YCPSWASYNConfig", 6, confArgs};

static void configCallFunc(const iocshArgBuf *args)
{
    YCPSWASYNConfig(args[0].sval, args[1].sval, args[2].sval, args[3].ival, args[4].sval, args[5].sval);
}

// YCPSWASYNSetDefaultScan
extern "C" int YCPSWASYNSetDefaultScan(double defaultScan)
{
    YCPSWASYN::defaultScan = defaultScan;

    return asynSuccess;
}

static const iocshArg defaultScanArg0 = { "defaultScan", iocshArgDouble };

static const iocshArg * const defaultScanArgs[] =
{
    &defaultScanArg0
};

static const iocshFuncDef defaultScanFuncDef = { "YCPSWASYNSetDefaultScan", 1, defaultScanArgs };

static void defaultScanCallFunc(const iocshArgBuf *args)
{
    YCPSWASYNSetDefaultScan(args[0].dval);
}

// YCPSWASYNSetPvMaxNameLen
extern "C" int YCPSWASYNSetPvMaxNameLen(int recordNameLenMax)
{
    if ( 0 == recordNameLenMax )
    {
        fprintf( stderr, "Error: PV name length must be greater than 0\n" );
        fprintf( stderr, "Keeping default value %d\n",  YCPSWASYN::recordNameLenMax );
        return asynError;
    }
    else
    {
        YCPSWASYN::recordNameLenMax = recordNameLenMax;
        return asynSuccess;
    }
}

static const iocshArg nameMaxLenArg0 =    { "recordNameLenMax", iocshArgInt };

static const iocshArg * const nameMaxLenArgs[] =
{
    &nameMaxLenArg0
};

static const iocshFuncDef nameMaxLenFuncDef = { "YCPSWASYNSetPvMaxNameLen", 1, nameMaxLenArgs };

static void nameMaxLenCallFunc(const iocshArgBuf *args)
{
    YCPSWASYNSetPvMaxNameLen(args[0].ival);
}

// YCPSWASYNSetMapFilePath
extern "C" int YCPSWASYNSetMapFilePath(const char* mapFilePath)
{
    if ( ( ! mapFilePath ) || ( mapFilePath[0] == '\0' ) )
    {
        fprintf( stderr, "Error: Path to map file is empty\n" );
        fprintf( stderr, "Keeping default value (%s).\n", YCPSWASYN::mapFilePath.c_str() );
        return asynError;
    }
    else
    {
        YCPSWASYN::mapFilePath = mapFilePath;

        if ( mapFilePath[ strlen( mapFilePath ) - 1 ] != '/' )
            YCPSWASYN::mapFilePath += '/';

        return asynSuccess;
    }
}

static const iocshArg mapFilePathArg0 = { "mapFilePath", iocshArgString };

static const iocshArg * const mapFilePathArgs[] =
{
    &mapFilePathArg0
};

static const iocshFuncDef mapFilePathFuncDef = { "YCPSWASYNSetMapFilePath", 1, mapFilePathArgs };

static void mapFilePathCallFunc(const iocshArgBuf *args)
{
    YCPSWASYNSetMapFilePath(args[0].sval);
}

// YCPSWASYNSetDebugFilePath
extern "C" int YCPSWASYNSetDebugFilePath(const char* debugFilePath)
{
    if ( ( ! debugFilePath ) || ( debugFilePath[0] == '\0' ) )
    {
        fprintf( stderr, "Error: Path to debug file is empty\n" );
        fprintf( stderr, "Keeping default value (%s).\n", YCPSWASYN::debugFilePath.c_str() );
        return asynError;
    }
    else
    {
        YCPSWASYN::debugFilePath = debugFilePath;

        if ( debugFilePath[ strlen( debugFilePath ) - 1 ] != '/' )
            YCPSWASYN::debugFilePath += '/';

        return asynSuccess;
    }
}

static const iocshArg debugFilePathArg0 = { "debugFilePath", iocshArgString };

static const iocshArg * const debugFilePathArgs[] =
{
    &debugFilePathArg0
};

static const iocshFuncDef debugFilePathFuncDef = { "YCPSWASYNSetDebugFilePath", 1, debugFilePathArgs };

static void debugFilePathCallFunc(const iocshArgBuf *args)
{
    YCPSWASYNSetDebugFilePath(args[0].sval);
}

// iocshRegister
void drvYCPSWASYNRegister(void)
{
    iocshRegister( &configFuncDef,        configCallFunc        );
    iocshRegister( &defaultScanFuncDef,   defaultScanCallFunc   );
    iocshRegister( &nameMaxLenFuncDef,    nameMaxLenCallFunc    );
    iocshRegister( &mapFilePathFuncDef,   mapFilePathCallFunc   );
    iocshRegister( &debugFilePathFuncDef, debugFilePathCallFunc );
}

extern "C" {
    epicsExportRegistrar(drvYCPSWASYNRegister);
}
